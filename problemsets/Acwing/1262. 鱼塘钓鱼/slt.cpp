#include <cstdio>

const int MAX_N  = 100 + 1;
const int MAX_T = 1000 + 1;

int n, t;
int w[MAX_N], d[MAX_N], c[MAX_N];
int dp[MAX_T];


/**
 * 对于第i个池塘，当T=j时，能够收获的最大利益等于j时间内，
 * 在池塘i钓鱼k分钟与在池塘i+1钓鱼j-k-c_i分钟等总共j+1种方案中的最大值。
 * 
 * 但是如果进行两趟遍历（MAX_T * (j+1))，将达到 O(T^2)复杂度。
 * 假设 F(T, i) 的最大值在 (k, T-k-C_i) 时取到，
 * 则对于F(T+1, i)来说，这多出来的一分钟，
 * 既可以选择加在池塘i上，也可以加在池塘i+1上，
 * 其最终的选择依据在于，加在哪个池塘上效益更高
 * 这里最关键的问题在于，
 * F(T, i)对应的(k, T-k-C_i)与 F(T+1, i)对应的(k', T-k'-C_i)之间
 * 具体是什么关系。
 * 
 * 首先肯定不是简单的加一减一关系
 * 因为当第i+1池塘的第一个数远大于第i个池塘时，将可以产生突变，比如
 * W[i, t] = [20, 20, 20, 20, 20, 20], W[i+1, t] = [90, 10, 0]
 * 而C[i] = 3，这样当T<=3时，k=3，即前3分钟都应该在第i个池塘，
 * 获得20+20+20=60条鱼。第四分钟将直接奔赴第i+1个池塘，一次性获得90条鱼。
 * 这是一种单向的过程，好像只要去了下一个池塘之后就不会再回来了，
 * 但这显然也是偷懒的思维，因为再来一分钟，就会发现
 * 呆在第i个池塘钓5分钟将与前往第i+1个池塘钓2分钟获得同样的100条鱼。
 * 但是紧接着又开始发生了变化，因为第i个池塘的减速远小于第i+1个池塘，
 * 所以接下来只要还有多余的时间，都不应该继续前往第i+1个池塘。
 * 而这一点，就是算法的性能关键：
 * 我们可以根据相邻两个鱼塘的递减幅度作出选择把多出来的时间分配在哪个池塘的决定，
 * 而不需要一趟又一趟的进行二次循环比大小。
 * 
 * ----------
 * 接下来，我们需要从第i+1个池塘的信息推导出第i个池塘的信息。
 * 首先，显然地，对于最后一个池塘，F(T, n) = \Sigma{W(n, j)}，
 * 其中W(n, j)表示对n个池塘，第j分钟能够钓鱼的数目，它是可以累加汇总的。
 * 我们注意到，如果W[i] >= W[i+1], D[i] <= D[i+1]，这种情况下，
 * 属于第i个池塘远优于第i+1个池塘，因此只要有时间都加在第i个池塘上，
 * 只有多出来的才有必要蔓延给i+1。
 * 这种情况在W[i] <= W[i+1], D[i] >= D[i+1]时相反，
 * 只不过需要考虑中间的赶路开销。
 * 
 * 但是当W[i] >= W[i+1], D[i] >= D[i+1]时，情况则略微复杂了一些。
 * 就如之前所考虑的，将会出现一些交叉点，一部分时间在i池塘好，一部分时间
 * 又是在i+1池塘更好，需要平衡。
 * 
 * 
 * 
void update()
{
		// 从右往左更新每个池塘每个T能收获的最大利益
	for(int i=n-1; i>0; i--)
	{

		for(int j=1; j<=T; j++)
		{

		}

	}
}

int main()
{
	scanf("%d", &n);
	for(int i=1; i<=n; i++) scanf("%d", &w[i]);
	for(int i=1; i<=n; i++) scanf("%d", &d[i]);
	for(int i=1; i< n; i++) scanf("%d", &c[i]);	
	scanf("%d", &t);

	// 初始化最后一个池塘每个T能收获的最大利益
	for(int i=1; i<=T; i++)
		dp[i] += max(w[n] - d[i] * (i-1), 0);
	
}