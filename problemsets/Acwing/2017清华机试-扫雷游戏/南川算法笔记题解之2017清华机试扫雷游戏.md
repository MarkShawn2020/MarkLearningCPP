## 2017清华计算机机试第三题【扫雷游戏】
### 关于kFlags的设计必要性
1. 容易想到，对于n\*m的数组，存储一个值表示周围的炸弹数，这是合理的。
2. 至于这个值是否需要包含自己，即炸弹自己要不要记1个true，则没有太大所谓。原因是程序只有在DSweep操作时，会涉及到周围炸弹数与周围旗帜数的比较，显然此时该格子必不是炸弹也必不是旗帜，于是加不加自身不影响比较的结果。
3. 在一开始，我为了更快地比较炸弹数和旗帜数，于是维护了另一个值，即周围的旗帜数，后来发现这是舍近求远，原因如下
   1. 首先为每个对象维护一个旗帜，是代价较高的，空间复杂度会高一些，其次每次插旗和拔旗都要遍历周围的数组，时间复杂度较高
   2. 更重要的，当我们维护了旗帜数与炸弹数后，我们虽然可以立即知道dsweep会不会遍历执行，于是我们就开始执行了，糟糕的是，一般情况下我们用的都是DFS，这个时候，如果在前几个结点进行了很深的遍历，最后碰到某一个周围结点炸了，这个机会成本就更高了。因为如果我们没有维护这个值，每次dsweep只要一趟遍历周围8个结点，遍历过程中再保存旗帜数、*错位数*这两个变量，最终如果旗帜数等于炸弹数，但错位数不等于0，则可以直接宣告游戏结束，无需触发不必要的的连锁反应！

### 关于Sweep和DSweep的套娃分析

基于kFlags的思考，很容易确定一种设计方案，该方案正好能更好地解决连锁反应的问题。

这道题的连锁反应其实是一个paper tiger，听起来很唬人，Sweep可能触发周围多个单元格的“Sweep”（即
“DSweep“），还可以通过DSweeo触发周围多个单元格的“Sweep”，似乎是一个死循环。（这里用引号表明，Sweep为0时触发的遍历并不等于DSweep，同样DSweep触发的遍历也不等于Sweep的集合）

实际上，这里面存在最小不可分割单元，即**对暂未操作（插旗、已探明都不算）的单元格的访问**。

先解释为什么插旗的不算，程序在访问到周围炸弹为0的单元格时，会触发对周围8个单元格的访问，并且还会牛逼轰轰的把这8个单元格上的旗帜都给拔掉，这是合理的，但这对程序设计造成了困难，因为还有另一种8单元格访问（即DSweep）是不支持拔旗的。

事实上，很容易理解得出，必然只存在一种最佳最小设计，也即刚刚说的：**对暂未操作的单元格的访问**。

基于这种设计，访问该单元格，如若是炸弹，则退出；如果是正值，则正常访问；如果是0，（这里需要注意），则开启8个单元格的访问，并在访问之前，先将所有的旗帜都撤销，（且过滤掉已访问的）这样，这8个单元格的遍历，便又回到了“**对暂未操作的单元格的访问**”这个最小函数。

那么，这个最小单元对DSweep操作是否也可以利用呢？答案显然是的，如果是盲目的遍历，可能没有太大效果，但是，如果基于我们上一个话题，先遍历周围8个判断是否会炸，不会炸的话再访问（此时不用先拔旗），这样的话，就又回到了“**对暂未操作的单元格的访问**”。

当我们确定了最小函数的设计后，其实我们已经完美地避开了无限套娃的过程，（*到底是Sweep套了DSweep还是DSweep套了Sweep，事实上，Sweep和DSweep的处理是不同的，它们有交集，但绝非子集，企图用一个Sweep函数解决一切，并在DSweep中调用Sweep的开发者（比如之前的我）将受到严厉的惩罚*），即在Sweep和DSweep函数内分别依赖这个最小函数，我们不妨将它命名为**CoreSweep**，对于CoreSweep函数来说，它所要处理的是必然未知（非有旗、非已扫）的单元格，对于另外两种单元格，将在Sweep和DSweep两个函数的内部，使用逻辑排除。

### 对于连锁反应的序列设计

在我们确定了最小设计单元之后，紧跟着要思考的就是连锁反应的序列返回问题。

先不讨论顺序问题（这关乎算法的选择与性能），先讨论逻辑问题（这关乎正确性）。

由于每次正常的Sweep和每次DSweep，都需要返回新访问的单元格序列，因为如果我们把Sweep和DSweep写成套娃函数，将对返回值的维护造成灾难性的影响。但如果把Sweep和DSweep都写成对CoreSweep函数的调用，这样两个函数都通过CoreSweep作为入口，能够非常容易地维护我们的单元格序列。

先分析Sweep函数，显然，当确定单元格可访问后，我们可以启动CoreSweep函数，进行“翻牌”，考虑到CoreSweep函数可能自我循环调用，因此比较合适的程序设计是在Sweep函数内初始化一个空列表，并把CoreSweep函数里所有访问到的结果都存进来，这样既可以使用指针方式跟踪空列表，也可以用纯粹的赋值方式进行管道连接，无论哪种设计，都是非常容易编写的。

再分析DSweep函数，显然，当确定不会爆炸后，我们可以启动一个for循环，循环体就是CoreSweep函数，并且在DSweep里初始化一个空列表，将CoreSweep的返回值不断接受即可，十分的方便。一旦周围8个都已经访问，那么得到列表为空，也就是答案中所谓的“no cell detected"，这样的设计也是非常吻合题意的。

接下来分析算法问题。在连锁反应的过程中，是否可以不使用优先级队列，仅使用dfs最终满足不排序而有序输出呢？答案不能直观地得出，我们尝试分析一下。要想使用dfs使之最终有序，我们必然要使最左上角的单元格优先访问，基于此如果我们能构造一个反例，使之从$a[x+1][y+1]$出发的连锁反应最终能触及到一个行数比从$a[x-1][y-1]$出发的连锁反应能触及到的单元格行数更小的单元格，那么就能证明dfs不能得到有序序列。

很显然，这是可能的，假设$a[x-1][y-1]$的左上半圈全是正数，即左上角直接封死，而右下角则一路畅通，再往上一路畅通，最终能得到一个单元格，比$y-1$更小。例如如下。（所以必须使用优先队列，或最终排序，否则得使用更高级的算法（比如病毒算法？）以提高算法效率）

|      |      |      |       |       |       |      |      |       |      |
| :--: | ---- | ---- | ----- | ----- | ----- | ---- | ---- | ----- | ---- |
|      |      |      |       |       |       |      |      |       |      |
|      |      |      |       |       |       |      |      | **S** |      |
|      |      | 1    | 1     | 1     | *     |      |      | 0     |      |
|      |      | 1    | **0** | 1     | 1     |      |      | 0     |      |
|      |      | 1    | 1     | **A** | 1     |      |      | 0     |      |
|      |      | *    | 1     | 1     | **0** | 0    | 0    | 0     |      |
|      |      |      |       |       |       |      |      |       |      |
|      |      |      |       |       |       |      |      |       |      |
|      |      |      |       |       |       |      |      |       |      |



### 关于炸弹数的统计方式

很自然地，如果在输入的时候，检查输入中带星号的数量或者记录其更详细的位置信息，是能够保证不出错的。

但是后来考虑到性能问题，将其放入sweep过程中进行增量统计，因为它会探测周围单元格中的是否为炸弹的信息。

但是这个方案后来引起了长达两个小时的debug，原因是，在第17个测例中，1*1000的单元格内，由于其狭长的布局原因，导致无论怎样都获取不到被两个地雷夹在中间的地雷信息，因而造成统计错误与程序判退错误。

![image-20210208154232052](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/picgo/image-20210208154232052.png)

### 性能优化记录

1. 将`vector<vector<int>> nxt`构造放到外面，优化了0.4毫秒
2. `++nBooms` -> `nBooms += his.size()`，优化了0.3毫秒，目前5.39毫秒
3. 放弃`nxt`迭代器，直接上升到1.7毫秒！
