//
// Created by 南川 on 2021/1/22.
//

/**
 * 洛谷P1886滑动窗口（模板-单调队列）题解，by 南川，2021年01月23日16:04:57
 * 1. 【引】
 *     本题使用单调队列，但大多数题解都是使用两条单边队列，这确实操作起来较为容易，也可以AC。
 *     但由于双单边队列的空间复杂度较高，时间复杂度也不见得低，因此考虑双端单调队列。
 *     首先，根据单调队列的思想，我们不妨设队列的最左边和最右边永远指向"有效的"最大结点和最小结点，
 *     显然，这里的"有效"指的是在窗口期内，否则可直接划去。接着，我们要保证整个队列"值"的有序。
 *
 * 2. 【单端队列思路与原理】
 * 2.1. 在单端队列中，我们可以维护"值"、"键"双有序，
 *      例如，输入数据为{3,1,4,2,5}，则必有大端队列为[3]->[3,1]->[3,2]->[4]->[4,2]->[5]，
 *      这里，除了值始终有序之外，最关键的两个基于时间的原则是，如果一个值既比该大端队列中的某个值大，而且还更"新"，
 *      即 v1>=v2 && t1>t2，显然对于第2个结点将会被挤出去，因为它既更容易被窗口淘汰，值也比不上第1个结点，
 *      我们称这种情况为"戴维斯双杀"。那么同样的，在小端队列中"戴维斯双杀"的情况也存在。
 * 2.2. 于是乎，我们可以知道，在大端队列中，能够"存活"下来"有效"的数据，必然是"值递减，键更大"。
 *      还是以上面的那个{3,1,4,2,5}为例，我们如果把其时间也记录下来，分析其队列中有多个值时的情况，就可以得到
 *      [(3,0), (1,1)] -> [(3,0), (2,3)] -> [(4,2), (2,3)]，其中0比1小、0比3小、2比3小。
 *      我们姑且称这样的值与键一致（尽管这是逆向的一致）的趋势，为"趋势一致性"。
 *      小端队列同样有此特点（但相反，顺向一致）。
 * 2.3. 基于以上的分析，使用两个单端队列写代码已经是顺水推舟的事情了，因为我们可以根据戴维斯双杀快速缩短队列，
 *      并根据背离一致性始终维护这个队列，head指针永远指向对头，tail指针不断浮动，最终能够AC。
 *      但，大端队列和小端队列如果混合在同一个队列中，会是什么样的场景呢？这，可就有意思多了！
 *
 * 3. 【双端队列的思路与原理】
 * 3.1. 在单端队列中，最有用的两个原则是"戴维斯双杀"和"趋势一致性"，但在双端队列中，这样的法条还适不适用呢？
 *      仍然考虑上面的示例，我们不妨使用一个双端队列（尽管我们还未论证可行性，但不妨采用试一试的办法）测试一下。
 *      第一个值是3，则队列为[(3,0)]，这次我们要记录一下时间下标。
 *      第二个值是1，则队列为[(3,0), (1,1)]，我们分析一下此时队列的情况，值递减、键递增。我们发现有意思的事情就发生了。
 *      如果我们从左往右看，值：3->1、键：0->1，这是满足大端队列的趋势一致性的，所以是合格的大端队列。
 *      但如果我们从右往左看，值：1->3、键：1->0，这是不满足小端队列的趋势一致性的，因为v1<v2 && t1>t2，
 *      这意味着第二个结点不但比第一个结点更大，还更旧（小端需要更小，且更新），
 *      因此第二个结点(3,0)（即正序第一个结点）在小端队列中被第一个结点（正序第二个结点）戴维斯双杀了！
 *      这给我们的启示是：在双端队列中，趋势一致性与戴维斯双杀将产生冲突（趋势一致性要求我们保留，但戴维斯双杀鼓励我们舍弃）。
 *      这样的矛盾对于双端队列的思路来说，是否是一个致命的打击呢？答案，未必。
 * 3.2. 由于我们必须奉行"取假>弃真"的策略，所以我们不得不放弃戴维斯双杀，而保留趋势一致性，留下(3,0)继续分析。
 *      第三个值是4，入队后为[(4,2), (3,0), (1,1)]，这个时候，本策略最最最最最最最最有意思的地方就来了！
 *      2>0<1，这说明什么？这说明从左往右看，4必然优于3（值和键都更大）；从右往左看，1也必优于3（值更小，键更大）。
 *      这说明(3,0)是一个两边都不讨好的存在，我们不妨称这样的局面为"V字深渊"，因为它被左右两个部落都遗忘了。
 *      于是乎，我们可以得到一个很重要的结论，在双端队列中，趋势一致性需要保留，戴维斯双杀将不起作用，取而代之的是，
 *      我们可以使用"V字深渊"，它即可以让我们的队列变得更短，还可以保证我们的队列始终满足"趋势一致性"。
 *      例如本例中，我们弃除(3,0)后，队列变为[(4,2), (1,1)]，这是一个合格的小端队列（尽管满足大端队列的戴维斯双杀）。
 * 3.3. 基于以上，我们开始对双端队列的前景充满信心。我们试着把接下来几个元素都入队看看。
 *      第四个值是2，队列变为[(4,2), (2,3), (1,1)]。然而，一种我们又没见过的场面出现了。
 *      2<3>1，这是与"V字深渊"完全相反的情况，在这种情况下，左边满足大端的一致性的，而右边满足小端的一致性，
 *      (2,3)这个点，于是它自动地将整个队列分成了左右两部分，我们不妨称这样的情况为"A字巅峰"。
 *      由于它是附近最新的点，我们没有理由把它弃除，它是屹立不倒巅峰的存在，并且左右逢源。
 *      但在我们驻足山巅的兴致之余，还是先把剩下的结点都分析完吧！
 * 3.4. 第五个值是5，队列变为[(5,4), (4,2), (2,3), (1,1)]，显然，此处(4,2)遭遇了"V字深渊"，它被我们无情弃除。
 *      于是队列更新为[(5,4), (2,3), (1,1)]，这就是一个非常完美的小端队列。
 *      如果我们的窗口规定T=3的话，右端点(1,1)将被弃除，最后得到这个队列此时的最大值为5，最小值为3。
 * 3.5. 分析至此，我们的双端队列的算法，应该付出水面了，那就是基于单端队列的算法做如下改进：
 *      1. 依旧需要对每个单端做窗口检测，以淘汰过期结点，由于我们的队列时刻更新，因此每次最多只有一个结点会过期，
 *         所以，我们只需要分别对左、右端点各检测一次既可以。（虽然过期结点可能在队列中，而非队列首尾）
 *      2. 接下来，我们任意取定一个方向（不妨从左端开始），向另一边（右边）遍历，将新的结点插入到值有序的合适位置，
 *         在遍历过程中，当我们遇到"V字深渊"时，可以放心大胆地将它删除，除此之外，我们则需要保留。
 *      3. 在结点的初始化过程中，我们的结点不断增多，而在之后，每一个周期我们都可能要移除0-1个结点，并保证插入一个结点，
 *         因此使用数组是不太合适的（单调队列之所以可行是因为单边固定（新结点优先级低于端点）或可覆盖（新结点优先级高于端点）），
 *         所以我们可以设计链表的结果，总体来看，不是一件很困难的事。
 * 3.6. 最终我设计出了一种父子二叉排序树的结构，它的左孩子大于自己的值，右孩子小于自己的值，父亲指向自己的父结点。
 *      我用了一个类去封装整个数据结构，并给这棵树提供了三个访问入口，即head（最大的结点，左下角）、tail（最小的结点，右下角）
 *      和root（最新进入的结点）。这棵树，每次加入一个结点，会基于这个新结点的值而选择归类于左子树亦或右子树，
 *      并相应地做一些技术性的调整，在调整完成之后，最后把根结点（即root）指向这个新的结点。
 *      这是一个非常有意思而又大胆的设计，事实上这棵树相当于两个单链二叉树，整体像一个大大的倒V字。
 *      测试下来，也能"AC"，效率仅略微次于使用两个单调队列。
 * 3.7. 还是有点不甘的，毕竟设计一个二叉树，维护其增删查改的工作量，可远大于使用单调队列，但值得，学习到了很多！
 */



#include "cstdio"
#include "tuple"

const int N = 1e6 + 1;


struct Node{
    int i, v;
    Node *L, *R, *fa;
};

class QueueTree
{
private:
    int T;
    Node * root, *h, *l;
public:
    explicit QueueTree(int m, int v): T(m) {
        h = l = root = new Node{0, v};
    }

    std::pair<int, int> addNode(int i, int v)
    {
        // 先移除左右两端可能过期的结点（过期结点只会在两端产生）
        if(i - h->i >= T) h = h->fa, free(h->L);
        if(i - l->i >= T) l = l->fa, free(l->R);

        Node * n = new Node{i, v};
        if(v >= h->v)       // 新结点最大
            n->R = root, root = root->fa = h = n;
        else if(v <= l->v)  // 新结点最小
            n->L = root, root = root->fa = l = n;
        else                // 新结点居队列中
        {
            Node * p = root;
            if(v >= root->v)    // 新结点在左链中
            {
                while (v >= p->v) {
                    p = p->L;
                    if(p->fa != root)
                        free(p->fa);
                }
                n->L = p, n->R = root;
            }
            else                // 新结点在右链中
            {
                while (v <= p->v){
                    p = p->R;
                    if(p->fa != root)
                        free(p->fa);
                }
                n->R = p, n->L = root;
            }
                root = root->fa = p->fa = n;
        }

        return std::make_pair(h->v, l->v);
    }
};

int main()
{
    //freopen("/Users/mark/CLionProjects/MarkLearningCPP/洛谷/P1886 滑动窗口 /【模板】单调队列/case1.txt", "r", stdin);

    int n, m;
    scanf("%d %d", &n, &m);

    int v;
    scanf("%d", &v);
    QueueTree qt(m, v);

    int ansLe[N], ansGe[N], h, l;
    for(int i=1; i<n; i++)
    {
        scanf("%d", &v);
        std::tie(h, l) = qt.addNode(i, v);

        if(i>=m-1)
            ansGe[i-m+1] = h, ansLe[i-m+1] = l;
    }

    // 小 -> 大
    for(int i=0; i<n-m+1; i++) printf("%d ", ansLe[i]);
    printf("\n");
    for(int i=0; i<n-m+1; i++) printf("%d ", ansGe[i]);

    return 0;

}