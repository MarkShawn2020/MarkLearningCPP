

# 南川算法笔记之一题详解dfs、bfs、IDA*算法

[HDOJ 1560. DNA Sequence]: Problem-1560-http://acm.hdu.edu.cn/showproblem.php?pid=1560	"HDOJ 1560. DNA Sequence"



> 本文感谢大佬的思路与代码：HDU1560 DNA sequence IDA* + 强力剪枝 [kuangbin带你飞]专题二_flyawayl的博客-CSDN博客 - https://blog.csdn.net/flyawayl/article/details/55667822

## 题目

![image-20210216072637286](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/20210216_072637_994606-image-20210216072637286.png)

![image-20210216072652089](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/20210216_072652_464462-image-20210216072652089.png)



## 解读

这题题目不长，目标就是**将几个字符串序列合并成一个新的，使得原来的每个字符串都是新串的子序列**，并求其**新序列的最短长度**。

惯性思维有时候会下意识想到最长公共子序列问题，然而确实不是同一类题，毕竟位置是离散的。

由于一开始知道这是一道搜索题（详见《罗勇军. 算法竞赛入门到进阶》p59），所以一开始就在想如何能够搜的更快点。

也想过dp，但是状态实在太多了，而且是多维的，编写非常不容易。在网上搜到一位使用搜索+dp+状态压缩的，结果性能十分之差，而且它的dp状态是6的6次方，空间几乎开到顶了。

因此本篇直接不考虑dp做法，如果大佬们有更好的dp思路，欢迎交流：877210964@qq.com。

## DFS 方案

首先，dfs的思路是直观的。每次选中一个字符，然后再挑选下一个，贪心地直到结尾，得到一个新序列后，再逐步回溯，确定下一个新序列，最后从所有的新序列中挑出一个最短的。

然而，由于本题的字符长度高达 $5\times 8=40$个，而且最大共有8个串，这意味着，在每一个时刻，都有8种选择，继续贪心所在串的下一个字符，或是从其他7个字符串中挑选下一个标记位字符。

所以这里面的关键问题是，选择空间爆炸，高达 $8^{40}$ ，也就是 $2^{120}$ 这是完全不可接受的。

### dfs 的优化一

在上述 dfs 思路中，有可以优化的吗？

考虑到我们的目标是找到最短的新串，所以在我们所有的解中，找到最短的那个串就行了，由于每个新串是一个个产生，并一个个接续开始进行的，由此，可以根据之前记录的串长对接下来串的生成过程进行剪枝。

具体的，比如说，沿着贪心的步骤第一步生成了“**ACGTATGCGTTCAGT**“，长度为15，其中第三个子串的第一个字符 C 与二个子串的结尾 C 相同，所以它被合并入了新串中（**我们的目标也是为了找到尽可能多的能合并的字符**）。

而在接下来的回溯过程中，由于只有第三个子串拥有选择的空间，所以从第三个子串可以重新选择下一个方向，生成了“**ACGTATGCGTCTAGT**”，可以看到，两个子串的长度实际是相同的，也就是说，新串并没有能够为后续的剪枝提供帮助。

这也是最致命的一点，无论对 朴素dfs 怎么优化，它都难以避免陷入大量无效解的空间中，在里面白费大量时间进行搜索。

![image-20210216115257868](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/20210216_115258_493172-image-20210216115257868.png)

### dfs 的实现一

尽管我们已经预感到，朴素dfs与目标剪枝的朴素dfs，都可能性能不及预期，但是这不妨碍我们实现一下，为后续的高级算法打好一个框架基础。

这也是很多难题的解决之道，**先用较为暴力，但不容易出错的思路写一版，确定思路的可行性，也可以用于后续的对拍与更优算法的性能衡量**。

当我们思考具体怎么用dfs实现时，我们碰到了一个较为重要的设计问题，是对每个原序列的下一个字符进行遍历呢？还是对目标序列的下一个可能字符遍历呢？答案是后者。

不然，如果我们每次对原序列的下一个字符进行遍历，则碰到下一个序列时，就需要重新和新串的结尾字符作对比，如果新串结尾是 C，而当前下一个字符也是 C，则要思考，这两个 C 是否可以合并，然而这是困难的，比如说，这个序列连续两个 C，第一个 C 可以和上一个序列的 C 合并，但是第二个却不可以。总之，这是极其繁琐的细节问题，然而可以直接通过另一种方案完全避免。也就是**只对目标序列的下一个可能字符进行遍历**。

更加准确地说，我们要写一个标记位数组和两层循环，循环外层是 ACGT，循环内层是 N 个输入序列。外层首先判断 A，然后在 N 个序列中把所有当前标记的 A 都给去掉，这样就不用在下一次再考虑是否合并了，因为标记位已经后移了。



### dfs 的优化二

基于上述在实现层面的分析，我们得到了第二个优化线索：**我们可以并行处理所有串**。

这或许可让程序性能有质的飞跃，我们在接下来的所有程序里，都将使用并行处理的思想，即每次对目标序列的下一个可能字符进行处理，并依次更新原多个序列中符合条件的当前字符，这看起来像是并行的一样。（如果可以使用多进程，这就是真地并行了，毕竟每个子序列都是独立的）。

![image-20210216092631193](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/20210216_092631_822372-image-20210216092631193.png)



然而，尽管我使用了并行处理 + 频度排序 + 目标剪枝，最终显示还是超时了。根据本地小规模的数据量测试，使用官方OJ运行30ms的程序在本地为0.06ms，而本程序在本地为0.29ms，相差有五倍，那么在官网数据量较大的情况下，可能相差百到千倍，超时（5000ms）也是很正常的。

朴素dfs的方案不可行，因为企图把所有可行的串都遍历完，以获得正确答案的时间代价实在是太高了。

## BFS 方案

事实上，富有经验的读者肯定知道，对于这类求最短的题，bfs 是更适合求解的。因为基于 bfs 可以实现层次遍历，每一层深度加一，直到遇到第一个解，程序直接退出，此时 bfs 的层数就是所求答案。

![image-20210216110944020](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/20210216_110944_624478-image-20210216110944020.png)

### bfs 优化：双向广搜

但考虑到本题的复杂性，朴素的bfs是完全不可行的，我们或许可以尝试一下双向广搜。

![image-20210216204336088](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/20210216_204336_660025-image-20210216204336088.png)



双向广搜在这道题的实现上，要略显困难一些，主要是遍历的方向、依据等，对最后的性能可能会产生影响。

比如考虑上述BFS右端的两种遍历结果，第一种无法与左端匹配（这意味着需要进一步加深bfs），第二种则可以匹配，而三个图都是4步遍历的结果，右二表明，程序最多可以在八步内有解。

#### 难点一：确定遍历的顺序

- 易知，倘若我们对遍历的顺序做一定调整，我们可先产生右二，然后检测到匹配成功，则直接退出，而无需再遍历到右一，也就是说，在能产生答案的那一层遍历中，有较大的优化空间，但在之前的层次中，则没有意义，因为我们无论如何都必须遍历那一层所有的可能选项，并记录下来。
- 但考虑到细节较为复杂，收益也不能很好的衡量（对于测例敏感），所以暂不优化。

#### 难点二：确定退出的条件

- 在之前的朴素 dfs 方案中，我们必须遍历完所有可能，最后确定一个最优解，显然这是代价巨大的。
- 在之前的朴素 bfs 方案中，我们只需要遍历到所有结点都已经遍历完即可，因此确定如何退出是简单的，可以通过计数，或者计算当前的 pos 数组。
- 但在双向广搜中，确定退出则要稍稍复杂一些，因为两边的遍历，可能完全不重合（就像两块拼图），也可能如这里的左一与右二一样，可能水乳交融，纽在了一起。
- 我们需要一个高效的确定退出方案，不然，我们只有遍历所有的已知结果，这个代价也是昂贵的。

#### 难点二的解决方案思考

![image-20210216210255833](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/20210216_210256_449734-image-20210216210255833.png)

![image-20210216210524743](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/20210216_210525_160572-image-20210216210524743.png)t尽管听起来可行，但是事实上，由于我们至少要更新一遍所有的空间内容，所以总操作次数依旧能达到

 $6^8$ 。并且由于我们要维护两个队列，频繁的操作产生着较大的开销。其次，对于数组的更新，由于我们每次每次获得的是一个新的 pos 数组，和原数组对比后，我们需要使用最多 8 次递归，完成 $2^8$ 个可能变动的更新，这样的开销是不容忽视的。

基于这些，实现了一版 DBFS 后，经测试发现性能很不理想，主要是队列与判退的操作，对性能影响较大。



## IDA*方案

### IDDFS 与 BFS

迭代加深搜索（Iterative Deepending DFS，IDDFS），主要用于解决一类搜索树既深又宽的题目。例如经典题目：埃及分数。

其主要思想是结合 DFS 和 BFS，首先设定搜索的深度为一个初始值（比如为1），然后用DFS进行搜索，如果没有找到答案则深度加一，如此迭代下去。这个迭代过程，在每一层的广度上采用了BFS搜索的思路（内层也可以使用DFS），但在外层则是DFS的。

尽管 IDDFS 听起来很适合求解最短路的问题，即一步步加深深度，直到在某一层能够找到一个解，那它和 BFS 比起来到底有什么优势呢？

事实上这是一个非常细致的问题。

试回忆一下，BFS 解决 DNS 这道题，模式是怎样的？会把所有的分支一个个地加入队列，一层层地传播下去。

因为 BFS 是盲目地、地毯式地搜索，它并不知道答案会在哪一层，所以它无法放弃任何一个死角，哪怕每次只加入一个新的字符（另外地搜索路径却可能每次加入多个新的字符）。

IDDFS呢？它先预设了一个答案，然后再进行搜索，由于目标深度是确定的，它就可以做出判断，即离在目标层以内完成搜索的可能性多大，如果确定不可行， 就可以进行剪枝了。这有点像打仗时派出的一些先头部队，只是用来快速确定敌方的力量与范围，方便主力最终确定准确的目标。

不过事实上，IIDDFS只是强调逐步加深深度这一操作，对于判断剪枝，则属于另外的内容，将 IDDFS  和 判断剪枝结合起来的算法名称叫做 IDA *。

### IDA* 与 A*

尽管 IDA* 算法是在 IDDFS 的基础上，根据一个判断函数（即估价函数）选择剪枝，但是值得注意的是，它依旧进行了部分的重复搜索。

比如本道题的样例，答案是8。那么当目标深度设置小于8时，肯定是无解的。比如说在设置目标深度为7时，搜索到某个位置，发现7层内无法得到答案，于是剪枝，也就是将这条路径放弃。当把所有7层内的可能路径都搜索完后，再考虑第8层的搜索。这个时候，却**有可能重新选择原来的那条路径，因为它不确定，原来在7层内完不成的任务，给定8层是否能够完成**。

从理论上来说，A\*是比ida\*更优的，但是场景却有不同。比如从棋盘上的一点到达一个点，这样的问题适合A\*，是因为可以方便地通过曼哈顿距离进行剪枝，比如逆向走路是肯定不会是最优解，绕路还需要掂量掂量。但对于DNA这道题，每一步肯定是加入一个新的字符，而且加入的字符不同，导致接下来的处境将会发生变化，这个时候使用A\*就很难去处理了，我们不太敢轻易剪枝，但是通过ida\*固定住最大长度，再剪枝，就顺理成章。

关于A\*算法的详细内容可以浏览罗勇军老师的博客：【链接】A\*搜索--算法竞赛专题解析（9）_罗勇军的博
https://blog.csdn.net/weixin_43914593/article/details/104935011

### IDA*算法的估价函数设计

事实上， 由于A\*算法和IDA\*算法都是启发式算法，所以，估价函数的设计就十分地关键，落实到程序中，将关乎到剪枝的多少，并决定最终的性能。

在本题中有多种启发函数的设计，我们可以由浅入深逐步分析每一种函数：

1. 剩余待遍历字符的总数
   1. 这个函数是最简单最直接的，当总数为0时表明已经遍历到了结束。
   2. 但是它无法作为剪枝函数，因为总数始终非负，一旦为0已经终结，无法做到提前判定一条路径不可行。
   3. 它也难以用于IDA\*算法中估价函数的设计，原因是剩余字符总数的意义与目标答案需行走的步数是不匹配的。剩余字符可能还有好几个，但是剩余步数可能只有一步或者寥寥几步，这无法用作估价。
   4. 综上，当使用朴素bfs时，剩余待遍历字符总数可作为退出条件，但是对于ida\*，意义则不达。
2. 剩余待遍历字符的总类数
   1. 显然，该函数一定程度上是可以作为简单的估价函数的，比如剩余字符总类数为3时，则至少还需要3步才能完成，一旦检测到自己的剩余步数不够时可以剪枝。
   2. 但由于字符总类数最大也就为4，所以很明显，这样的函数剪枝效果是很不明显的。
3. 直接取最长待匹配子串长度（来自flyawayl大佬）
   1. 这个函数和上者差不多性能，因为每个字符最长也就是5，比4仅大于1，根据大佬测试，耗时为 1900 ms，勉强能过。
4. **取每种字符剩余最大匹配长度之和**（来自flyawayl大佬）。
   1. 这个思想非常优秀，显著比前两者更接近真实的答案，因为每类字符的剩余匹配次数至少是所有子序列中该字符频次的最大值，而且也大概率不会超出特别多。
   2. 此外，这个函数的实现也不算困难，只要每次遍历 $4*8=32$ 个数即可，属于常数复杂度。
   3. 也有考虑使用堆优化进一步加快运算速度，但是考虑到每一次可能修改多个非对顶元素，这导致需要使用延迟修改等技术，实现难度更高，而且基于`stl`的`priority_queue`与备份，将导致性能可能更差。
5. 基于逆序对的判别。
   1. 这个方法，比较复杂，需要算出所有元素之间的拓扑关系，具体可以见下表。
   2. 这个方法有两个比较明显的问题，第一是不如基于频度算法那么直观与容易实现，第二则是尽管代价较高，却依旧不一定是最优解，并且忽视了一些其他的线性关系，比如 ACGT 是一个线性关系，代表至少有 4 个字符，但仅凭逆序对则不太能捕捉如此简单的关系，所以需要改进，但改进的门槛却比其他函数更高，如果你有更好的办法欢迎联系我： 877210964@qq.com，或公众号：南川笔记。

![image-20210217234607758](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/20210217_234608_420798-image-20210217234607758.png)



## 基于分组最大频度汇总的估价函数的IDA*方案代码实现

```c++
//
// Created by 南川 on 2021/2/17.
// Problem - 1560 - http://acm.hdu.edu.cn/showproblem.php?pid=1560
//
#include "cstdio"
#include "cstring"
using std::memset;
using std::memcpy;

/**
 * for global
 */
const int N_SEQS = 8;           // 每个测例最大的串数
const int N_LENS = 5;           // 每串最大长度
const int N_TYPE = 4;           // 字符总类
int nCases;                     // 测例数

const int dict[20] = {          // 字符转数字
        1, 0, 2, 0, 0, 0, 3,    // A, C, G
        0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 4        // T
};


/**
 * for each case
 */
int nSeqs;                          // 输入串数
char seq[N_LENS];                   // 接收字符串
int seqs[N_SEQS][N_LENS];           // 每个串的整型存储
int lens[N_SEQS];                   // 每个串的长度
int minAns;                         // 答案


/**
 * 深度递归过程中的状态信息，用于回溯
 */
struct State {
    int steps;                      // 基于steps与surplus判退
    int pos[N_SEQS];                // 记录位置便宜，必须
    int freqs[N_TYPE + 1][N_SEQS];  // 快速统计当前剩余匹配数目，避免较高计算占用
    int maxFreq[N_TYPE + 1];        // 快速统计每类字符最大的频度，用于计算剩余步数
    int nxtFreq[N_TYPE + 1];        // 快速统计下一个可能的字符，避免无效备份State，无需重置，递推更新

    void reset() {
        steps = 0;
        memset(pos,     0, sizeof pos);
        memset(freqs,   0, sizeof freqs);
        memset(maxFreq, 0, sizeof maxFreq);
    }

    /**
     * 该函数将目前的状态里，所有子序列中排头为某id的元素全部去除
     * 是状态更新的关键函数，将影响状态内的所有数据结构（不影响的我也不会加入状态了）
     * @param id
     */
    void offsetPos(const int & id) {
        ++steps;
        for(int i=0; i < nSeqs; ++i)    // 更新位置与频度
            if(pos[i] < lens[i] && seqs[i][pos[i]] == id)
            {
                if(--freqs[id][i] == maxFreq[id] - 1)
                    updateMaxFreq(id);
                --nxtFreq[id];
                if(++pos[i] < lens[i])
                    ++nxtFreq[seqs[i][pos[i]]];
            }
    }

    /**
     * 这个函数的主要原理，就是当某子序列的某id频度是所有子序列中最大的那一个时，
     * 它的变动将可能影响最终所有子序列该id的最大频度，于是对这个id的最大频度重新更新；
     * 而对于其他非最大频度的子序列，它们更新该id值时则不会调用此函数
     * 因此该函数或许可以节省一定的开销（但并不一定，比如当所有子序列某id频度都相等时）
     * @param id
     */
    inline void updateMaxFreq(int id) { // 最大八步
        int r1 = 0;
        for(int i=0; i < nSeqs; ++i)
            if(r1 < freqs[id][i])
                r1 = freqs[id][i];
        maxFreq[id] = r1;
    }

    /**
     * 这个函数是本程序的估价函数，非常重要，用于初始化答案、剪枝与最终答案的确定
     * 它统计接下来每种字符在所有子序列中的最大值的汇总，代表接下来至少还需多少步完成
     * 当它将至0时说明已经找到了一个解（结合iddfs，就是最优解）
     * 而当它与已走步数相加，超过给定步数限制时，则进行剪枝
     * @return
     */
    inline int checkSurplus() { // 最大四步
        int r1 = 0;
        for(int id=1; id<=4; ++id)
            r1 += maxFreq[id];
        return r1;
    }
}state;

/**
 * 【主函数】每个case的递归求解
 */
bool recurSolve()
{
    for(int id = 1; id <= 4; ++id)
    {
        if(!state.nxtFreq[id]) continue;                // 避免不必要的的备份
        State stateBack(state);                         // backup
        state.offsetPos(id);                            // update
        int surplus = state.checkSurplus();             // check
        if(state.steps + surplus <= minAns && (!surplus || recurSolve()))               // 成功退出
            return true;                                // success
        else state = stateBack;                         // rollback
    }
    return false;
}

/**
 * 求解每个case的框架函数
 */
void solveCase()
{
    state.reset();                                      // reset state
    scanf("%d", &nSeqs);
    for(int i = 0; i < nSeqs; ++i)
    {
        scanf("%s", seq);
        lens[i] = strlen(seq);                          // 记录每个字符串长度
        ++state.nxtFreq[dict[seq[0]-'A']];
        for(int j = 0; j < lens[i]; ++j)
        {
            const int & id = dict[seq[j] - 'A'];        // 将字符串转为数字存储
            ++state.freqs[id][i];
            seqs[i][j] = id;
        }
    }
    for(int id = 1; id <= 4; ++id)                      // 更新每类字符的最大频度
        state.updateMaxFreq(id);

    minAns = state.checkSurplus();                      // 初始化答案
    while (!recurSolve()) ++minAns;                     // 当无解时，迭代加深
    printf("%d\n", minAns);
}

/**
 * 求解全部case的框架函数
 */
int main()
{
    freopen("/Users/mark/MarkLearningCPP/HDOJ/1560. DNA sequence/case2.txt", "r", stdin);

    scanf("%d", &nCases);
    while (nCases--) solveCase();
    return 0;
}

```

### 结果评估

![image-20210217235154252](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/20210217_235154_906270-image-20210217235154252.png)